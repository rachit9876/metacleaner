<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image Cleaner - Remove Metadata, Convert to WebP | Free Online Tool</title>
<meta name="description" content="Free no upload image cleaner tool. Remove EXIF metadata, convert images to WebP format offline. Strip GPS data and protect privacy - all processing happens locally in your browser without uploading files.">
<meta name="keywords" content="image cleaner, metadata remover, webp converter, exif remover, image to webp, remove gps data, privacy tool, image optimizer, no upload image cleaner, offline image processor, client side image converter">
<meta name="robots" content="index, follow">
<meta property="og:title" content="Image Cleaner - Remove Metadata & Convert to WebP">
<meta property="og:description" content="Free tool to clean image metadata and convert to WebP. Remove EXIF, GPS data for privacy protection.">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Image Cleaner - Metadata Remover & WebP Converter">
<meta name="twitter:description" content="Clean image metadata and convert to WebP format. Privacy-focused image processing tool.">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Alata&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Alata&display=swap"></noscript>
<link rel="stylesheet" href="style.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body class="dark-theme">
<h2>Image Cleaner</h2>
<p class="subtitle">(No Upload)<br>Removes metadata, Convert to webp, Random of Filename</p>

<div class="container">
  <div class="row">
    <input id="file" type="file" accept="image/*" multiple>
    <div class="file-input-wrapper" onclick="document.getElementById('file').click()">
      Choose Images
    </div>
  </div>

  <div class="controls collapsed">
    <div class="control-group">
      <label>Quality <span id="qval">0.80</span></label>
      <input id="quality" type="range" min="0.05" max="1" step="0.05" value="0.80">
    </div>

    <div class="control-group">
      <label>Noise Level <span id="nval">0.5</span></label>
      <input id="noise" type="range" min="0" max="3" step="0.1" value="0.5">
    </div>

    <div class="control-group">
      <label>Max Width (px)</label>
      <input id="maxw" type="number" min="1" placeholder="Original size">
    </div>

    <div class="control-group">
      <label>Tight crop (2px)</label>
      <div class="toggle" id="autocrop"><div class="toggle-slider"></div></div>
    </div>
    
    <div class="control-group">
      <label>Randomize filename</label>
      <div class="toggle" id="randomize"><div class="toggle-slider"></div></div>
    </div>
    
    <div class="control-group">
      <label>Keep original extension</label>
      <div class="toggle" id="keepExtension"><div class="toggle-slider"></div></div>
    </div>
  </div>

  <div class="row">
    <button id="advancedBtn">Advanced</button>
    <button id="convert" disabled>Download</button>
    <button id="previewBtn" disabled>Convert</button>
    <button id="bulkConvert" style="display:none" disabled>Bulk Convert</button>
    <button id="bulkDownload" style="display:none" disabled>Bulk Download ZIP</button>
  </div>
</div>

<button id="resetBtn" class="purple-btn">Reset</button>

<div id="images-container" class="images-container"></div>

<div id="processed-images-container" class="images-container" style="display:none">
  <h3>Processed Images</h3>
</div>



<div style="position:absolute;left:-9999px;opacity:0;height:1px;overflow:hidden;">
  <h1>Image Cleaner - Professional Metadata Remover and WebP Converter</h1>
  <p>Best free no upload image cleaner tool to remove metadata from photos offline. Convert images to WebP format while stripping EXIF data, GPS coordinates, and camera information. Protect your privacy with our advanced offline image to webp converter that removes all hidden metadata from JPEG, PNG, and other image formats without uploading files to any server.</p>
  <h2>Features of Our Image Metadata Remover:</h2>
  <ul>
    <li>Remove EXIF metadata from images completely</li>
    <li>Convert image to webp format with high quality</li>
    <li>Strip GPS location data from photos</li>
    <li>Bulk image processing and conversion</li>
    <li>Privacy-focused image cleaner tool</li>
    <li>No upload required - process images locally offline</li>
    <li>Client-side image processing without server upload</li>
    <li>Offline image cleaner and webp converter</li>
    <li>No file upload image metadata remover</li>
  </ul>
  <h3>Why Use Our Image to WebP Converter?</h3>
  <p>Our image cleaner removes sensitive metadata including camera settings, GPS coordinates, timestamps, and device information. Convert your images to efficient WebP format while ensuring complete privacy protection. Perfect for photographers, bloggers, and privacy-conscious users who need a reliable metadata remover tool.</p>
</div>

<div class="security-note">
  <h3 onclick="togglePrivacyFeatures()" style="cursor:pointer;">Privacy Protection Features ▼</h3>
  <div id="privacyFeatures" style="max-height:0;overflow:hidden;transition:max-height 0.3s ease;">
    <ul>
      <li><strong>Complete Metadata Removal:</strong> Strip all EXIF data, GPS coordinates, and camera information</li>
      <li><strong>WebP Conversion:</strong> Convert images to efficient WebP format while cleaning metadata</li>
      <li><strong>Filename Randomization:</strong> Prevents identification through naming patterns</li>
      <li><strong>Pixel Noise Addition:</strong> Subtle alterations to break perceptual hash matching</li>
      <li><strong>No Upload Required:</strong> All processing happens offline in your browser</li>
      <li><strong>Client-Side Processing:</strong> Images never leave your device or get uploaded to servers</li>
    </ul>
    <p><strong>Perfect for privacy-conscious users:</strong> Clean image metadata without uploading files. Use with Tor/VPN for maximum anonymity.</p>
  </div>
</div>

<canvas id="c" style="display:none"></canvas>

<script>
const fileEl = document.getElementById('file');
const convertBtn = document.getElementById('convert');
const previewBtn = document.getElementById('previewBtn');


const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { willReadFrequently: true });

// Controls
const qualityEl = document.getElementById('quality');
const qval = document.getElementById('qval');
const noiseEl = document.getElementById('noise');
const nval = document.getElementById('nval');
const maxwEl = document.getElementById('maxw');
const autocropEl = document.getElementById('autocrop');
const randomizeEl = document.getElementById('randomize');
const keepExtensionEl = document.getElementById('keepExtension');
const advancedBtn = document.getElementById('advancedBtn');
const controlsEl = document.querySelector('.controls');

// Load saved settings
function loadSettings() {
  const quality = sessionStorage.getItem('quality');
  const noise = sessionStorage.getItem('noise');
  const maxWidth = sessionStorage.getItem('maxWidth');
  const autocrop = sessionStorage.getItem('autocrop') === 'true';
  const randomize = sessionStorage.getItem('randomize') === 'true';
  const keepExtension = sessionStorage.getItem('keepExtension') === 'true';
  const advancedOpen = sessionStorage.getItem('advancedOpen') === 'true';
  
  if (quality) { qualityEl.value = quality; qval.textContent = quality; }
  if (noise) { noiseEl.value = noise; nval.textContent = noise; }
  if (maxWidth) maxwEl.value = maxWidth;
  if (autocrop) autocropEl.classList.add('active');
  if (randomize) randomizeEl.classList.add('active');
  if (keepExtension) keepExtensionEl.classList.add('active');
  if (advancedOpen) {
    controlsEl.classList.remove('collapsed');
    advancedBtn.textContent = 'Hide Advanced';
  }
}

// Save settings
function saveSettings() {
  sessionStorage.setItem('quality', qualityEl.value);
  sessionStorage.setItem('noise', noiseEl.value);
  sessionStorage.setItem('maxWidth', maxwEl.value);
  sessionStorage.setItem('autocrop', autocropEl.classList.contains('active'));
  sessionStorage.setItem('randomize', randomizeEl.classList.contains('active'));
  sessionStorage.setItem('keepExtension', keepExtensionEl.classList.contains('active'));
  sessionStorage.setItem('advancedOpen', !controlsEl.classList.contains('collapsed'));
}

// Advanced toggle
advancedBtn.addEventListener('click', () => {
  const isCollapsed = controlsEl.classList.contains('collapsed');
  controlsEl.classList.toggle('collapsed');
  advancedBtn.textContent = isCollapsed ? 'Hide Advanced' : 'Advanced';
  saveSettings();
});



// Update value displays
qval.textContent = qualityEl.value;
qualityEl.oninput = () => { qval.textContent = qualityEl.value; saveSettings(); };
nval.textContent = noiseEl.value;
noiseEl.oninput = () => { nval.textContent = noiseEl.value; saveSettings(); };
maxwEl.oninput = saveSettings;

let currentFiles = [];


// Toggle functionality
autocropEl.addEventListener('click', () => {
  autocropEl.classList.toggle('active');
  saveSettings();
});

randomizeEl.addEventListener('click', () => {
  randomizeEl.classList.toggle('active');
  saveSettings();
});

keepExtensionEl.addEventListener('click', () => {
  keepExtensionEl.classList.toggle('active');
  saveSettings();
});

// Reset session
document.getElementById('resetBtn').addEventListener('click', () => {
  sessionStorage.clear();
  location.reload();
});

// Load settings on page load
loadSettings();

// Event listeners
fileEl.addEventListener('change', e => {
  const files = Array.from(e.target.files);
  if (files.length > 0) {
    // If we already have files, merge with new ones
    if (currentFiles.length > 0) {
      currentFiles = [...currentFiles, ...files];
    } else {
      currentFiles = files;
    }
    displayImages(currentFiles);
    enableButtons();
  }
});



// Page-wide drag and drop with animation
document.addEventListener('dragover', e => {
  e.preventDefault();
  document.body.classList.add('drag-over');
});

document.addEventListener('dragleave', e => {
  if (!e.relatedTarget) {
    document.body.classList.remove('drag-over');
  }
});

document.addEventListener('drop', e => {
  e.preventDefault();
  document.body.classList.remove('drag-over');
  const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
  if (files.length > 0) {
    // If we already have files, merge with new ones
    if (currentFiles.length > 0) {
      currentFiles = [...currentFiles, ...files];
    } else {
      currentFiles = files;
    }
    displayImages(currentFiles);
    enableButtons();
  } else if (e.dataTransfer.files.length > 0) {
    alert('Please drop only image files.');
  }
});

// Clipboard paste
document.addEventListener('paste', e => {
  const items = e.clipboardData.items;
  for (let i = 0; i < items.length; i++) {
    if (items[i].type.startsWith('image/')) {
      const f = items[i].getAsFile();
      // If we already have files, add to existing array
      if (currentFiles.length > 0) {
        currentFiles = [...currentFiles, f];
      } else {
        currentFiles = [f];
      }
      displayImages(currentFiles);
      enableButtons();
      break;
    }
  }
});



// Format file size
function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Update display after file selection
function displayImages(files) {
  const container = document.getElementById('images-container');
  container.innerHTML = '';
  container.style.justifyContent = files.length > 0 ? 'flex-start' : 'center';
  
  files.forEach((file, index) => {
    const imageBox = document.createElement('div');
    imageBox.className = 'image-box';
    imageBox.innerHTML = `
      <div class="image-preview">
        <img class="preview-image" alt="${file.name}">
        <div class="image-info">
          <span class="image-name">${file.name}</span>
          <span class="image-size">${formatFileSize(file.size)}</span>
        </div>
      </div>
    `;
    
    const img = imageBox.querySelector('img');
    const url = urlManager.create(file);
    img.src = url;
    
    container.appendChild(imageBox);
  });
  
  updateBulkButton();
  enableButtons();
}

// Display processed images
function displayProcessedImages(results) {
  const container = document.getElementById('processed-images-container');
  container.innerHTML = '<h3>Processed Images</h3><div class="processed-images-grid"></div>';
  container.style.display = 'block';
  
  const grid = container.querySelector('.processed-images-grid');
  
  results.forEach((result, index) => {
    const imageBox = document.createElement('div');
    imageBox.className = 'image-box processed';
    imageBox.innerHTML = `
      <div class="image-preview">
        <img class="preview-image" alt="${result.filename}">
        <div class="image-info">
          <span class="image-name">${result.filename}</span>
          <span class="image-size">${formatFileSize(result.blob.size)}</span>
          <span class="processed-label">✓ Processed</span>
        </div>
      </div>
    `;
    
    const img = imageBox.querySelector('img');
    const url = urlManager.create(result.blob);
    img.src = url;
    
    grid.appendChild(imageBox);
  });
}

// Load image
function loadImage(url) {
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res(img);
    img.onerror = rej;
    img.src = url;
  });
}

// Apply noise to image data
function applyNoise(imageData, intensity) {
  if (!intensity) return imageData;
  const d = imageData.data;
  for (let i = 0; i < d.length; i += 4) {
    const noise = (Math.random() * 2 - 1) * intensity;
    d[i] = Math.max(0, Math.min(255, d[i] + noise));
    d[i+1] = Math.max(0, Math.min(255, d[i+1] + noise));
    d[i+2] = Math.max(0, Math.min(255, d[i+2] + noise));
  }
  return imageData;
}

// Process image and return blob
async function processImage(file, opts) {
  const url = URL.createObjectURL(file);
  const img = await loadImage(url);
  
  // Calculate dimensions
  let width = img.width;
  let height = img.height;
  if (opts.maxWidth && opts.maxWidth < width) {
    const scale = opts.maxWidth / width;
    width = Math.round(width * scale);
    height = Math.round(height * scale);
  }
  
  // Set canvas size
  canvas.width = width;
  canvas.height = height;
  
  // Draw image with optional crop
  const inset = opts.autocrop ? 2 : 0;
  ctx.drawImage(img, inset, inset, img.width - inset*2, img.height - inset*2, 0, 0, width, height);
  
  // Apply noise if needed
  if (opts.noise > 0) {
    const imageData = ctx.getImageData(0, 0, width, height);
    ctx.putImageData(applyNoise(imageData, opts.noise), 0, 0);
  }
  
  // Determine output format
  const outputType = opts.keepExtension && file.type ? file.type : 'image/webp';
  const quality = outputType === 'image/jpeg' ? opts.quality : (outputType === 'image/webp' ? opts.quality : undefined);
  
  // Create blob
  const blob = await new Promise(resolve => {
    canvas.toBlob(resolve, outputType, quality);
  });
  
  URL.revokeObjectURL(url);
  return { blob, width, height, outputType };
}

// Generate random 6-character filename
function randomFilename(extension = '.webp') {
  const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < 6; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result + extension;
}

// Get file extension from MIME type
function getExtensionFromType(type) {
  const extensions = {
    'image/jpeg': '.jpg',
    'image/png': '.png',
    'image/webp': '.webp',
    'image/gif': '.gif',
    'image/bmp': '.bmp'
  };
  return extensions[type] || '.webp';
}

// Enable buttons when files are loaded
function enableButtons() {
  const convertBtn = document.getElementById('convert');
  const previewBtn = document.getElementById('previewBtn');
  const bulkConvertBtn = document.getElementById('bulkConvert');
  
  convertBtn.disabled = false;
  previewBtn.disabled = false;
  bulkConvertBtn.disabled = false;
}

// Show/hide buttons based on file count
function updateBulkButton() {
  const convertBtn = document.getElementById('convert');
  const previewBtn = document.getElementById('previewBtn');
  const bulkConvertBtn = document.getElementById('bulkConvert');
  const bulkDownloadBtn = document.getElementById('bulkDownload');
  
  if (currentFiles.length > 1) {
    // Multiple images: show bulk buttons, hide single buttons
    convertBtn.style.display = 'none';
    previewBtn.style.display = 'none';
    bulkConvertBtn.style.display = 'inline-block';
    bulkDownloadBtn.style.display = 'inline-block';
  } else {
    // Single image: show single buttons, hide bulk buttons
    convertBtn.style.display = 'inline-block';
    previewBtn.style.display = 'inline-block';
    bulkConvertBtn.style.display = 'none';
    bulkDownloadBtn.style.display = 'none';
  }
}

let processedResults = [];



// URL manager to prevent memory leaks
const urlManager = {
  urls: new Set(),
  create(blob) {
    const url = URL.createObjectURL(blob);
    this.urls.add(url);
    return url;
  },
  cleanup() {
    this.urls.forEach(url => URL.revokeObjectURL(url));
    this.urls.clear();
  }
};

// Unified processing function
async function processBulk(files, shouldDownload = false) {
  urlManager.cleanup();
  const isSingle = files.length === 1;
  const btn = isSingle ? (shouldDownload ? convertBtn : previewBtn) : document.getElementById('bulkConvert');
  
  btn.disabled = true;
  btn.textContent = 'Processing...';
  processedResults = [];
  
  try {
    const opts = {
      quality: parseFloat(qualityEl.value),
      noise: parseFloat(noiseEl.value),
      maxWidth: maxwEl.value ? parseInt(maxwEl.value) : null,
      autocrop: autocropEl.classList.contains('active'),
      keepExtension: keepExtensionEl.classList.contains('active')
    };
    
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      if (!isSingle) btn.textContent = `Processing ${i + 1}/${files.length}...`;
      
      const result = await processImage(file, opts);
      const extension = opts.keepExtension ? getExtensionFromType(result.outputType) : '.webp';
      const filename = randomizeEl.classList.contains('active') ? randomFilename(extension) : `${file.name.split('.')[0]}${extension}`;
      
      processedResults.push({
        blob: result.blob,
        filename: filename,
        width: result.width,
        height: result.height
      });
    }
    
    displayProcessedImages(processedResults);
    document.getElementById('bulkDownload').disabled = false;
    
    if (isSingle && shouldDownload) {
      const result = processedResults[0];
      const dlUrl = URL.createObjectURL(result.blob);
      const a = document.createElement('a');
      a.href = dlUrl;
      a.download = result.filename;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(dlUrl);
    }
    
  } catch (err) {
    console.error(err);
    alert('Error processing images: ' + err.message);
  } finally {
    btn.disabled = false;
    btn.textContent = isSingle ? (shouldDownload ? 'Download' : 'Convert') : 'Bulk Convert';
  }
}

// Bulk convert button
document.getElementById('bulkConvert').addEventListener('click', async () => {
  if (currentFiles.length === 0) return;
  await processBulk(currentFiles);
});

// Bulk download ZIP button
document.getElementById('bulkDownload').addEventListener('click', async () => {
  if (processedResults.length === 0) {
    alert('Please convert images first');
    return;
  }
  
  const downloadBtn = document.getElementById('bulkDownload');
  downloadBtn.disabled = true;
  downloadBtn.textContent = 'Creating ZIP...';
  
  try {
    const zip = new JSZip();
    
    processedResults.forEach((result, index) => {
      zip.file(result.filename, result.blob);
    });
    
    const zipBlob = await zip.generateAsync({type: 'blob'});
    const zipUrl = URL.createObjectURL(zipBlob);
    
    const a = document.createElement('a');
    a.href = zipUrl;
    a.download = 'metacleaner.zip';
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(zipUrl);
    
  } catch (err) {
    console.error('Error creating ZIP:', err);
    alert('Error creating ZIP file');
  } finally {
    downloadBtn.disabled = false;
    downloadBtn.textContent = 'Bulk Download ZIP';
  }
});

// Convert button - uses bulk processing for single file
convertBtn.addEventListener('click', async () => {
  if (currentFiles.length === 0) {
    alert('Please select an image first');
    return;
  }
  
  // Process using bulk method
  await processBulk([currentFiles[0]], true);
});

// Preview button - uses bulk processing for single file
previewBtn.addEventListener('click', async () => {
  if (currentFiles.length === 0) {
    alert('Please select an image first');
    return;
  }
  
  // Process using bulk method without download
  await processBulk([currentFiles[0]], false);
});

// Toggle privacy features
function togglePrivacyFeatures() {
  const features = document.getElementById('privacyFeatures');
  const container = features.parentElement;
  const header = features.previousElementSibling;
  if (features.style.maxHeight === '0px' || !features.style.maxHeight) {
    // Expanding: first animate border-radius, then content
    container.classList.add('expanded');
    setTimeout(() => {
      features.style.maxHeight = features.scrollHeight + 'px';
      header.innerHTML = 'Privacy Protection Features ▲';
    }, 300);
  } else {
    // Collapsing: first collapse content, then animate border-radius
    features.style.maxHeight = '0px';
    header.innerHTML = 'Privacy Protection Features ▼';
    setTimeout(() => {
      container.classList.remove('expanded');
    }, 300);
  }
}
</script>
</body>
</html>